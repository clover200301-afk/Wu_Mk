{
  "version": 3,
  "sources": ["../../hast-util-from-dom/lib/index.js", "../../hast-util-from-html-isomorphic/lib/browser.js", "../../rehype-katex/lib/index.js"],
  "sourcesContent": ["/**\n * @import {\n *   Comment as HastComment,\n *   Doctype as HastDoctype,\n *   Element as HastElement,\n *   Nodes as HastNodes,\n *   RootContent as HastRootContent,\n *   Root as HastRoot,\n *   Text as HastText,\n * } from 'hast'\n */\n\n/**\n * @callback AfterTransform\n *   Callback called when each node is transformed.\n * @param {Node} domNode\n *   DOM node that was handled.\n * @param {HastNodes} hastNode\n *   Corresponding hast node.\n * @returns {undefined | void}\n *   Nothing.\n *\n *   Note: `void` included until TS infers `undefined` nicely.\n *\n * @typedef Options\n *   Configuration.\n * @property {AfterTransform | null | undefined} [afterTransform]\n *   Callback called when each node is transformed (optional).\n */\n\nimport {h, s} from 'hastscript'\nimport {webNamespaces} from 'web-namespaces'\n\n/**\n * Transform a DOM tree to a hast tree.\n *\n * @param {Node} tree\n *   DOM tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNodes}\n *   Equivalent hast node.\n */\nexport function fromDom(tree, options) {\n  return transform(tree, options || {}) || {type: 'root', children: []}\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n *\n *   Note that certain legacy DOM nodes (i.e., Attr nodes (2),  CDATA, processing instructions)\n */\nfunction transform(node, options) {\n  const transformed = one(node, options)\n  if (transformed && options.afterTransform)\n    options.afterTransform(node, transformed)\n  return transformed\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n */\nfunction one(node, options) {\n  switch (node.nodeType) {\n    case 1 /* Element */: {\n      const domNode = /** @type {Element} */ (node)\n      return element(domNode, options)\n    }\n\n    // Ignore: Attr (2).\n\n    case 3 /* Text */: {\n      const domNode = /** @type {Text} */ (node)\n      return text(domNode)\n    }\n\n    // Ignore: CDATA (4).\n    // Removed: Entity reference (5)\n    // Removed: Entity (6)\n    // Ignore: Processing instruction (7).\n\n    case 8 /* Comment */: {\n      const domNode = /** @type {Comment} */ (node)\n      return comment(domNode)\n    }\n\n    case 9 /* Document */: {\n      const domNode = /** @type {Document} */ (node)\n      return root(domNode, options)\n    }\n\n    case 10 /* Document type */: {\n      return doctype()\n    }\n\n    case 11 /* Document fragment */: {\n      const domNode = /** @type {DocumentFragment} */ (node)\n      return root(domNode, options)\n    }\n\n    default: {\n      return undefined\n    }\n  }\n}\n\n/**\n * Transform a document.\n *\n * @param {Document | DocumentFragment} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastRoot}\n *   Equivalent hast node.\n */\nfunction root(node, options) {\n  return {type: 'root', children: all(node, options)}\n}\n\n/**\n * Transform a doctype.\n *\n * @returns {HastDoctype}\n *   Equivalent hast node.\n */\nfunction doctype() {\n  return {type: 'doctype'}\n}\n\n/**\n * Transform a text.\n *\n * @param {Text} node\n *   DOM node to transform.\n * @returns {HastText}\n *   Equivalent hast node.\n */\nfunction text(node) {\n  return {type: 'text', value: node.nodeValue || ''}\n}\n\n/**\n * Transform a comment.\n *\n * @param {Comment} node\n *   DOM node to transform.\n * @returns {HastComment}\n *   Equivalent hast node.\n */\nfunction comment(node) {\n  return {type: 'comment', value: node.nodeValue || ''}\n}\n\n/**\n * Transform an element.\n *\n * @param {Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastElement}\n *   Equivalent hast node.\n */\nfunction element(node, options) {\n  const space = node.namespaceURI\n  const x = space === webNamespaces.svg ? s : h\n  const tagName =\n    space === webNamespaces.html ? node.tagName.toLowerCase() : node.tagName\n  /** @type {DocumentFragment | Element} */\n  const content =\n    // @ts-expect-error: DOM types are wrong, content can exist.\n    space === webNamespaces.html && tagName === 'template' ? node.content : node\n  const attributes = node.getAttributeNames()\n  /** @type {Record<string, string>} */\n  const properties = {}\n  let index = -1\n\n  while (++index < attributes.length) {\n    properties[attributes[index]] = node.getAttribute(attributes[index]) || ''\n  }\n\n  return x(tagName, properties, all(content, options))\n}\n\n/**\n * Transform child nodes in a parent.\n *\n * @param {Document | DocumentFragment | Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {Array<HastRootContent>}\n *   Equivalent hast nodes.\n */\nfunction all(node, options) {\n  const nodes = node.childNodes\n  /** @type {Array<HastRootContent>} */\n  const children = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const child = transform(nodes[index], options)\n\n    if (child !== undefined) {\n      // @ts-expect-error Assume no document inside document.\n      children.push(child)\n    }\n  }\n\n  return children\n}\n", "/**\n * @typedef {import('hast').Root} Root\n *\n * @typedef {typeof import('./index.js').fromHtmlIsomorphic} FromHtmlIsomorphic\n */\n\nimport {fromDom} from 'hast-util-from-dom'\n\nconst parser = new DOMParser()\n\n/** @type {FromHtmlIsomorphic} */\nexport function fromHtmlIsomorphic(value, options) {\n  const node = options?.fragment\n    ? parseFragment(value)\n    : parser.parseFromString(value, 'text/html')\n\n  return /** @type {Root} */ (fromDom(node))\n}\n\n/**\n * Parse as a fragment.\n *\n * @param {string} value\n * @returns {DocumentFragment}\n */\nfunction parseFragment(value) {\n  const template = document.createElement('template')\n  template.innerHTML = value\n  return template.content\n}\n", "/**\n * @import {ElementContent, Root} from 'hast'\n * @import {KatexOptions} from 'katex'\n * @import {VFile} from 'vfile'\n */\n\n/**\n * @typedef {Omit<KatexOptions, 'displayMode' | 'throwOnError'>} Options\n */\n\nimport {fromHtmlIsomorphic} from 'hast-util-from-html-isomorphic'\nimport {toText} from 'hast-util-to-text'\nimport katex from 'katex'\nimport {SKIP, visitParents} from 'unist-util-visit-parents'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n/** @type {ReadonlyArray<unknown>} */\nconst emptyClasses = []\n\n/**\n * Render elements with a `language-math` (or `math-display`, `math-inline`)\n * class with KaTeX.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeKatex(options) {\n  const settings = options || emptyOptions\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @param {VFile} file\n   *   File.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree, file) {\n    visitParents(tree, 'element', function (element, parents) {\n      const classes = Array.isArray(element.properties.className)\n        ? element.properties.className\n        : emptyClasses\n      // This class can be generated from markdown with ` ```math `.\n      const languageMath = classes.includes('language-math')\n      // This class is used by `remark-math` for flow math (block, `$$\\nmath\\n$$`).\n      const mathDisplay = classes.includes('math-display')\n      // This class is used by `remark-math` for text math (inline, `$math$`).\n      const mathInline = classes.includes('math-inline')\n      let displayMode = mathDisplay\n\n      // Any class is fine.\n      if (!languageMath && !mathDisplay && !mathInline) {\n        return\n      }\n\n      let parent = parents[parents.length - 1]\n      let scope = element\n\n      // If this was generated with ` ```math `, replace the `<pre>` and use\n      // display.\n      if (\n        element.tagName === 'code' &&\n        languageMath &&\n        parent &&\n        parent.type === 'element' &&\n        parent.tagName === 'pre'\n      ) {\n        scope = parent\n        parent = parents[parents.length - 2]\n        displayMode = true\n      }\n\n      /* c8 ignore next -- verbose to test. */\n      if (!parent) return\n\n      const value = toText(scope, {whitespace: 'pre'})\n\n      /** @type {Array<ElementContent> | string | undefined} */\n      let result\n\n      try {\n        result = katex.renderToString(value, {\n          ...settings,\n          displayMode,\n          throwOnError: true\n        })\n      } catch (error) {\n        const cause = /** @type {Error} */ (error)\n        const ruleId = cause.name.toLowerCase()\n\n        file.message('Could not render math with KaTeX', {\n          ancestors: [...parents, element],\n          cause,\n          place: element.position,\n          ruleId,\n          source: 'rehype-katex'\n        })\n\n        // KaTeX *should* handle `ParseError` itself, but not others.\n        // it doesn’t always:\n        // <https://github.com/remarkjs/react-markdown/issues/853>\n        try {\n          result = katex.renderToString(value, {\n            ...settings,\n            displayMode,\n            strict: 'ignore',\n            throwOnError: false\n          })\n        } catch {\n          // Generate similar markup if this is an other error.\n          // See: <https://github.com/KaTeX/KaTeX/blob/5dc7af0/docs/error.md>.\n          result = [\n            {\n              type: 'element',\n              tagName: 'span',\n              properties: {\n                className: ['katex-error'],\n                style: 'color:' + (settings.errorColor || '#cc0000'),\n                title: String(error)\n              },\n              children: [{type: 'text', value}]\n            }\n          ]\n        }\n      }\n\n      if (typeof result === 'string') {\n        const root = fromHtmlIsomorphic(result, {fragment: true})\n        // Cast as we don’t expect `doctypes` in KaTeX result.\n        result = /** @type {Array<ElementContent>} */ (root.children)\n      }\n\n      const index = parent.children.indexOf(scope)\n      parent.children.splice(index, 1, ...result)\n      return SKIP\n    })\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AA2CO,SAAS,QAAQ,MAAM,SAAS;AACrC,SAAO,UAAU,MAAM,WAAW,CAAC,CAAC,KAAK,EAAC,MAAM,QAAQ,UAAU,CAAC,EAAC;AACtE;AAYA,SAAS,UAAU,MAAM,SAAS;AAChC,QAAM,cAAc,IAAI,MAAM,OAAO;AACrC,MAAI,eAAe,QAAQ;AACzB,YAAQ,eAAe,MAAM,WAAW;AAC1C,SAAO;AACT;AAUA,SAAS,IAAI,MAAM,SAAS;AAC1B,UAAQ,KAAK,UAAU;AAAA,IACrB,KAAK,GAAiB;AACpB,YAAM;AAAA;AAAA,QAAkC;AAAA;AACxC,aAAO,QAAQ,SAAS,OAAO;AAAA,IACjC;AAAA,IAIA,KAAK,GAAc;AACjB,YAAM;AAAA;AAAA,QAA+B;AAAA;AACrC,aAAO,KAAK,OAAO;AAAA,IACrB;AAAA,IAOA,KAAK,GAAiB;AACpB,YAAM;AAAA;AAAA,QAAkC;AAAA;AACxC,aAAO,QAAQ,OAAO;AAAA,IACxB;AAAA,IAEA,KAAK,GAAkB;AACrB,YAAM;AAAA;AAAA,QAAmC;AAAA;AACzC,aAAO,KAAK,SAAS,OAAO;AAAA,IAC9B;AAAA,IAEA,KAAK,IAAwB;AAC3B,aAAO,QAAQ;AAAA,IACjB;AAAA,IAEA,KAAK,IAA4B;AAC/B,YAAM;AAAA;AAAA,QAA2C;AAAA;AACjD,aAAO,KAAK,SAAS,OAAO;AAAA,IAC9B;AAAA,IAEA,SAAS;AACP,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAYA,SAAS,KAAK,MAAM,SAAS;AAC3B,SAAO,EAAC,MAAM,QAAQ,UAAU,IAAI,MAAM,OAAO,EAAC;AACpD;AAQA,SAAS,UAAU;AACjB,SAAO,EAAC,MAAM,UAAS;AACzB;AAUA,SAAS,KAAK,MAAM;AAClB,SAAO,EAAC,MAAM,QAAQ,OAAO,KAAK,aAAa,GAAE;AACnD;AAUA,SAAS,QAAQ,MAAM;AACrB,SAAO,EAAC,MAAM,WAAW,OAAO,KAAK,aAAa,GAAE;AACtD;AAYA,SAAS,QAAQ,MAAM,SAAS;AAC9B,QAAM,QAAQ,KAAK;AACnB,QAAM,IAAI,UAAU,cAAc,MAAM,IAAI;AAC5C,QAAM,UACJ,UAAU,cAAc,OAAO,KAAK,QAAQ,YAAY,IAAI,KAAK;AAEnE,QAAM;AAAA;AAAA,IAEJ,UAAU,cAAc,QAAQ,YAAY,aAAa,KAAK,UAAU;AAAA;AAC1E,QAAM,aAAa,KAAK,kBAAkB;AAE1C,QAAM,aAAa,CAAC;AACpB,MAAI,QAAQ;AAEZ,SAAO,EAAE,QAAQ,WAAW,QAAQ;AAClC,eAAW,WAAW,KAAK,CAAC,IAAI,KAAK,aAAa,WAAW,KAAK,CAAC,KAAK;AAAA,EAC1E;AAEA,SAAO,EAAE,SAAS,YAAY,IAAI,SAAS,OAAO,CAAC;AACrD;AAYA,SAAS,IAAI,MAAM,SAAS;AAC1B,QAAM,QAAQ,KAAK;AAEnB,QAAM,WAAW,CAAC;AAClB,MAAI,QAAQ;AAEZ,SAAO,EAAE,QAAQ,MAAM,QAAQ;AAC7B,UAAM,QAAQ,UAAU,MAAM,KAAK,GAAG,OAAO;AAE7C,QAAI,UAAU,QAAW;AAEvB,eAAS,KAAK,KAAK;AAAA,IACrB;AAAA,EACF;AAEA,SAAO;AACT;;;ACrNA,IAAM,SAAS,IAAI,UAAU;AAGtB,SAAS,mBAAmB,OAAO,SAAS;AACjD,QAAM,QAAO,mCAAS,YAClB,cAAc,KAAK,IACnB,OAAO,gBAAgB,OAAO,WAAW;AAE7C;AAAA;AAAA,IAA4B,QAAQ,IAAI;AAAA;AAC1C;AAQA,SAAS,cAAc,OAAO;AAC5B,QAAM,WAAW,SAAS,cAAc,UAAU;AAClD,WAAS,YAAY;AACrB,SAAO,SAAS;AAClB;;;ACbA,IAAM,eAAe,CAAC;AAEtB,IAAM,eAAe,CAAC;AAWP,SAAR,YAA6B,SAAS;AAC3C,QAAM,WAAW,WAAW;AAY5B,SAAO,SAAU,MAAM,MAAM;AAC3B,iBAAa,MAAM,WAAW,SAAUA,UAAS,SAAS;AACxD,YAAM,UAAU,MAAM,QAAQA,SAAQ,WAAW,SAAS,IACtDA,SAAQ,WAAW,YACnB;AAEJ,YAAM,eAAe,QAAQ,SAAS,eAAe;AAErD,YAAM,cAAc,QAAQ,SAAS,cAAc;AAEnD,YAAM,aAAa,QAAQ,SAAS,aAAa;AACjD,UAAI,cAAc;AAGlB,UAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,YAAY;AAChD;AAAA,MACF;AAEA,UAAI,SAAS,QAAQ,QAAQ,SAAS,CAAC;AACvC,UAAI,QAAQA;AAIZ,UACEA,SAAQ,YAAY,UACpB,gBACA,UACA,OAAO,SAAS,aAChB,OAAO,YAAY,OACnB;AACA,gBAAQ;AACR,iBAAS,QAAQ,QAAQ,SAAS,CAAC;AACnC,sBAAc;AAAA,MAChB;AAGA,UAAI,CAAC,OAAQ;AAEb,YAAM,QAAQ,OAAO,OAAO,EAAC,YAAY,MAAK,CAAC;AAG/C,UAAI;AAEJ,UAAI;AACF,iBAAS,MAAM,eAAe,OAAO;AAAA,UACnC,GAAG;AAAA,UACH;AAAA,UACA,cAAc;AAAA,QAChB,CAAC;AAAA,MACH,SAAS,OAAO;AACd,cAAM;AAAA;AAAA,UAA8B;AAAA;AACpC,cAAM,SAAS,MAAM,KAAK,YAAY;AAEtC,aAAK,QAAQ,oCAAoC;AAAA,UAC/C,WAAW,CAAC,GAAG,SAASA,QAAO;AAAA,UAC/B;AAAA,UACA,OAAOA,SAAQ;AAAA,UACf;AAAA,UACA,QAAQ;AAAA,QACV,CAAC;AAKD,YAAI;AACF,mBAAS,MAAM,eAAe,OAAO;AAAA,YACnC,GAAG;AAAA,YACH;AAAA,YACA,QAAQ;AAAA,YACR,cAAc;AAAA,UAChB,CAAC;AAAA,QACH,QAAQ;AAGN,mBAAS;AAAA,YACP;AAAA,cACE,MAAM;AAAA,cACN,SAAS;AAAA,cACT,YAAY;AAAA,gBACV,WAAW,CAAC,aAAa;AAAA,gBACzB,OAAO,YAAY,SAAS,cAAc;AAAA,gBAC1C,OAAO,OAAO,KAAK;AAAA,cACrB;AAAA,cACA,UAAU,CAAC,EAAC,MAAM,QAAQ,MAAK,CAAC;AAAA,YAClC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,UAAI,OAAO,WAAW,UAAU;AAC9B,cAAMC,QAAO,mBAAmB,QAAQ,EAAC,UAAU,KAAI,CAAC;AAExD;AAAA,QAA+CA,MAAK;AAAA,MACtD;AAEA,YAAM,QAAQ,OAAO,SAAS,QAAQ,KAAK;AAC3C,aAAO,SAAS,OAAO,OAAO,GAAG,GAAG,MAAM;AAC1C,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AACF;",
  "names": ["element", "root"]
}
